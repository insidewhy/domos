import {$each, compCss, css} from './util'

var SWITCH_ATTRS = ['opacity', 'width', 'height']

// in chromium dimensions/opacity after transitions are not always exact
// so allow this much deviation when testing for completion
var VERY_SMALL = 0.00001

// Currently only affects firefox: https://bugzil.la/849399
// Some browsers report new opacity incorrectly immediately after a switch
// causes a transition. A delay is used after resetting styles as a
// work-around.
var STATE_INCORRECT_AFTER_SET =
  /Firefox\/(?:1[7-9]|20)?/.test(navigator.userAgent),
    STATE_INCORRECT_AFTER_SET_LAG = 20 // 10 is a bit too small

var TRANSITIONS_AUTO_AS_0px =
  /Chrome\/2[0-6]?/.test(navigator.userAgent)

/// Transition selector containing one or many HTML elements.
export function transition(nodes, name, value, callback) {
  var changes
  if (typeof name === 'string') {
    changes = {}
    changes[name] = value
  }
  else {
    changes = name
    callback = value
  }

  var changeTypes = Object.keys(changes),
      nChanges    = changeTypes.length

  changeTypes.some(type => {
    if (SWITCH_ATTRS.indexOf(type) !== -1 &&
        parseFloat(changes[type]) > VERY_SMALL)
    {
      nodes.show()
    }
  })

  var nTrans = nodes.length
  if (! callback || nTrans === 1) {
    transitionElement(nodes, changeTypes, changes, callback)
  }
  else {
    var hasBeenCancelled = false, nTransitions = nodes.length

    var onSingleTransition = cancelled => {
      if (hasBeenCancelled)
        return

      if (cancelled)
        callback(hasBeenCancelled = true)
      else if (! --nTrans)
        callback()
    }

    $each(nodes, node => {
      transitionElement(node, changeTypes, changes, onSingleTransition)
    })
  }
}

var removeTransitionState = (nod, type, removeEmpty) => {
  if (nod.__domosTransition[type]) {
    delete nod.__domosTransition[type]
    if (--nod.__domosTransition.nKeys === 0 && removeEmpty)
      delete nod.__domosTransition
  }
}

/// Transition selector containing single HTML element.
function transitionElement(node, changeTypes, _changes, callback) {
  var changes = Object.create(_changes)
  var autoTypes = []

  // handle transitions to and from auto
  var handleAutos = () => {
    changeTypes.forEach(type => {
      if (_changes[type] === 'auto')
        autoTypes.push(type)

      var val = node[0].style[type]
      if (val === '' || val === 'auto')
        css(node, type, compCss(node, type))
    })
  }

  // firefox needs a delay after this step else the transition will not fire
  var makeCssChanges = () => {
    node.css(changes)

    var pendingChanges = () =>
      changeTypes.some(type =>
        Math.abs(parseFloat(compCss(node, type))
                 - parseFloat(changes[type])) > VERY_SMALL)

    var finishedTransition = false

    // this helper is necessary due to https://bugzil.la/849399
    if (pendingChanges()) {
      // a transition occurred
      var nod = node[0]

      // "end of transition" html5 event handler
      var handleTransition = e => {
        if (finishedTransition)
          return

        if (! e) {
          // when the event is not present this means the function
          // was cancelled by the user
          if (callback)
            callback(true)

          finishedTransition = true
          return
        }

        if (SWITCH_ATTRS.indexOf(e.propertyName) !== -1 &&
            parseFloat(compCss(node, e.propertyName)) < VERY_SMALL)
        {
          node.css('display', 'none')
        }

        if (! pendingChanges()) {
          // transition completed
          changeTypes.forEach(type => {
            removeTransitionState(nod, type, true)
          })
          nod.removeEventListener('transitionend', handleTransition)
          nod.removeEventListener('webkitTransitionEnd', handleTransition)

          finishedTransition = true
          withoutTransitions(
            () => {
              autoTypes.forEach(type => { css(node, type, 'auto') })
            }, callback)
        }
      } // end of transition end callback

      if (nod.__domosTransition) {
        changeTypes.forEach(type => {
          // show it has cancelled
          var listener = nod.__domosTransition[type]
          if (listener) {
            listener(null)
            // calling twice on same listener has no effect
            nod.removeEventListener('transitionend', listener)
            nod.removeEventListener('webkitTransitionEnd', listener)

            removeTransitionState(nod, type)
          }
        })
      }
      else {
        nod.__domosTransition = {}
      }

      changeTypes.forEach(type => {
        nod.__domosTransition[type] = handleTransition
      })
      nod.__domosTransition.nKeys = changeTypes.length

      nod.addEventListener('transitionend', handleTransition)
      nod.addEventListener('webkitTransitionEnd', handleTransition)
    }
    else {
      if (changeTypes.some(type =>
            SWITCH_ATTRS.indexOf(type) !== -1 &&
            parseFloat(changes[type]) < VERY_SMALL))
      {
          node.css('display', 'none')
      }

      if (callback)
        callback()
    }
  }

  var isAuto = type => {
    var nodeVal = node[0].style[type]
    return nodeVal === '' || nodeVal === 'auto'
  }

  var withoutTransitions = (without, after) => {
    if (TRANSITIONS_AUTO_AS_0px) {
      var backupTrans = compCss(node, 'transition')
      css(node, 'transition', 'none')
      if (without)
        without()
      setTimeout(() => {
        css(node, 'transition', backupTrans)
        if (after)
          after()
      })
    }
    else {
      if (without)
        without()
      if (after)
        after()
    }
  }

  var makeCssChangesHelper = () => {
    if (STATE_INCORRECT_AFTER_SET)
      setTimeout(makeCssChanges, STATE_INCORRECT_AFTER_SET_LAG)
    else
      makeCssChanges()
  }

  if (TRANSITIONS_AUTO_AS_0px && changeTypes.some(isAuto)) {
    // to fix transition from auto then set types that have auto
    // to the computed size
    withoutTransitions(handleAutos, makeCssChangesHelper)
  }
  else {
    handleAutos()

    if (autoTypes.length) {
      withoutTransitions(() => {
        autoTypes.forEach(type => {
          var bak = compCss(node, type)
          css(node, type, 'auto')
          changes[type] = compCss(node, type)
          css(node, type, bak)
        })
      }, makeCssChangesHelper)
    }
    else {
      makeCssChangesHelper()
    }
  }
}

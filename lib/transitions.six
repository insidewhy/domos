import {$each, compCss, css} from './util'

var SWITCH_ATTRS = ['opacity', 'width', 'height']

// in chromium dimensions/opacity after transitions are not always exact
// so allow this much deviation when testing for completion
var VERY_SMALL = 0.00001

// Currently only affects firefox: https://bugzil.la/849399
// Some browsers report new opacity incorrectly immediately after a switch
// causes a transition. A delay is used after resetting styles as a
// work-around.
var STATE_INCORRECT_AFTER_SET =
  /Firefox\/(?:1[7-9]|20)?/.test(navigator.userAgent),
    STATE_INCORRECT_AFTER_SET_LAG = 20 // 10 is a bit too small

var TRANSITIONS_FROM_AUTO_AS_0px =
  /Chrome\/2[0-6]?/.test(navigator.userAgent)

/// Transition selector containing one or many HTML elements.
export function transition(nodes, name, value, callback) {
  var changes
  if (typeof name === 'string') {
    changes = {}
    changes[name] = value
  }
  else {
    changes = name
    callback = value
  }

  var changeTypes = Object.keys(changes),
      nChanges    = changeTypes.length

  changeTypes.some(type => {
    if (SWITCH_ATTRS.indexOf(type) !== -1 &&
        parseFloat(changes[type]) > VERY_SMALL)
    {
      nodes.show()
    }
  })

  var nTrans = nodes.length
  if (! callback || nTrans === 1) {
    transitionElement(nodes, changeTypes, changes, callback)
  }
  else {
    var hasBeenCancelled = false, nTransitions = nodes.length

    var onSingleTransition = cancelled => {
      if (hasBeenCancelled)
        return

      if (cancelled)
        callback(hasBeenCancelled = true)
      else if (! --nTrans)
        callback()
    }

    $each(nodes, node => {
      transitionElement(node, changeTypes, changes, onSingleTransition)
    })
  }
}

var removeTransitionState = (nod, type, removeEmpty) => {
  if (nod.__domosTransition[type]) {
    delete nod.__domosTransition[type]
    if (--nod.__domosTransition.nKeys === 0 && removeEmpty)
      delete nod.__domosTransition
  }
}

/// Transition selector containing single HTML element.
function transitionElement(node, changeTypes, changes, callback) {
  var blankCss = () => {
    changeTypes.forEach(type => {
      if (node[0].style[type] === '')
        css(node, type, compCss(node, type))
    })
  }

  // firefox needs a delay after this step else the transition will not fire
  var makeCssChanges = () => {
    node.css(changes)

    var pendingChanges = () =>
      changeTypes.some(type =>
        Math.abs(parseFloat(compCss(node, type))
                 - parseFloat(changes[type])) > VERY_SMALL)

    var finishedTransition = false

    // this helper is necessary due to https://bugzil.la/849399
    if (pendingChanges()) {
      // a transition occurred
      var nod = node[0]

      // "end of transition" html5 event handler
      var handleTransition = e => {
        if (finishedTransition)
          return

        if (! e) {
          // when the event is not present this means the function
          // was cancelled by the user
          if (callback)
            callback(true)

          finishedTransition = true
          return
        }

        if (SWITCH_ATTRS.indexOf(e.propertyName) !== -1 &&
            parseFloat(compCss(node, e.propertyName)) < VERY_SMALL)
        {
          node.css('display', 'none')
        }

        if (! pendingChanges()) {
          // transition completed
          changeTypes.forEach(type => {
            removeTransitionState(nod, type, true)
          })
          nod.removeEventListener('transitionend', handleTransition)
          nod.removeEventListener('webkitTransitionEnd', handleTransition)
          if (callback)
            callback()
          finishedTransition = true
        }
      } // end of transition end callback

      if (nod.__domosTransition) {
        changeTypes.forEach(type => {
          // show it has cancelled
          var listener = nod.__domosTransition[type]
          listener(null)
          // calling twice on same listener has no effect
          nod.removeEventListener('transitionend', listener)
          nod.removeEventListener('webkitTransitionEnd', listener)

          removeTransitionState(nod, type)
        })
      }
      else {
        nod.__domosTransition = {}
      }

      changeTypes.forEach(type => {
        nod.__domosTransition[type] = handleTransition
      })
      nod.__domosTransition.nKeys = changeTypes.length

      nod.addEventListener('transitionend', handleTransition)
      nod.addEventListener('webkitTransitionEnd', handleTransition)
    }
    else {
      if (changeTypes.some(type =>
            SWITCH_ATTRS.indexOf(type) !== -1 &&
            parseFloat(changes[type]) < VERY_SMALL))
      {
          node.css('display', 'none')
      }

      if (callback)
        callback()
    }
  }

  // to fix transition from auto then set types that have auto
  // to the computed size
  if (TRANSITIONS_FROM_AUTO_AS_0px &&
      changeTypes.some(type => node[0].style[type] === ''))
  {
    var backupTrans = compCss(node, 'transition')
    css(node, 'transition', 'none')
    blankCss()
    // there seems to be a lag before the transition turning off can take
    // place so delaying by 0s is a good way of dealing with this
    setTimeout(() => {
      css(node, 'transition', backupTrans)
      makeCssChanges()
    }, 0)
    return
  }
  else {
    blankCss()
  }

  if (STATE_INCORRECT_AFTER_SET)
    setTimeout(makeCssChanges, STATE_INCORRECT_AFTER_SET_LAG)
  else
    makeCssChanges()
}

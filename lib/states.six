import transition from './transitions'

export var transitionTypes = {
  show: {
      // TODO: only if element is shown?
    undoAction(node)    { return 'hide' },
    run(node, callback) { transition(node, 'opacity', 1, callback) }
  },
  hide: {
    run(node, callback) { transition(node, 'opacity', 0, callback) }
  }
}

export class States {
  constructor(opts) {
    _.extend(this, Backbone.Events)

    if (! opts)
      opts = {}

    // map of state type to related parent selector
    this._selectorMap     = opts.selectorMap || {}
    // default selector for states with no selector in map
    this._defaultSelector = opts.default || $('body')

    // Prefix used in data tags before state name
    this.statePrefix = opts.statePrefix || 's-'

    // table of current state values by type
    this.state = {}
  }

  /// Change elements below a parent selector according to data tags denoting
  /// how the tag should look depending on certain states.
  /// @param type       State type.
  /// @param val        Value of state.
  /// @param callback   Optional callback to run after all operations have
  ///                   complete.
  /// @param sel        Override parent by which to limit elements to change.
  set(type, val, callback, sel) {
    if (val === null || val === 'null') {
      if (! this.state[type]) {
        this.trigger('redo-' + type + '-null')
        return
      }

      // the field-change event will contain the string null
      val = 'null'
      delete this.state[type]
    }
    else {
      if (this.state[type] === val) {
        this.trigger('redo-' + type + '-' + val, val)
        return
      }

      this.state[type] = val
    }

    // TODO: handle ordering better here
    var transitions = this._getTransitions(type, val)

    var runAfter = () => {
      if (callback)
        callback()
      this.trigger('state-change', this.state)
      this.trigger(type + '-' + val, val)
    }

    if (transitions.hide && transitions.show) {
      // If there are both elements to fade out and in, then only start
      // fading in after the elements to fade out are gone.
      transition(transitions.hide, 'opacity', 0, cancelled => {
        if (cancelled)
          return

        delete transitions.hide
        this._runTransitions(transitions, runAfter)
      })
    }
    else
      this._runTransitions(transitions, runAfter)
  }

  _runTransitions(transitions, callback) {
    var actions = Object.keys(transitions)
    var nActions = actions.length
    actions.forEach(action => {
      transitionTypes[action].run(transitions[action])
      if (! --nActions && callback)
        callback()
    })
  }

  _selectorFor(type) {
    return this._selectorMap[type] || this._defaultSelector
  }

  /// Get transitions relating to a state.
  /// @param sel Optional override parent by which to limit elements to
  //         change (otherwise selectorMap/default is used).
  _getTransitions(type, val, sel) {
    var transitions   = {},
        addTransition = (name, node) => {
          var existing = transitions[name]
          transitions[name] = existing ? existing.add(node) : node
        }

    if (! sel)
      sel = this._selectorFor(type)

    var dataTag = 'data-' + this.statePrefix + type
    _.each(sel.find('[' + dataTag + ']'), node => {
      node = $(node)
      var matches = {}, failures = {}

      // $().data(type) converts string 'null' to js null
      node.attr(dataTag).split('|').forEach(state => {
        var colonIdx = state.indexOf(':'), action = 'show'
        if (colonIdx !== -1) {
          action = state.substr(colonIdx + 1)
          if (! transitionTypes[action])
            throw new Error('invalid transition type ' + action)
          state  = state.substr(colonIdx)
        }

        var result = state[0] === '!' ?
          val !== state.substr(1) : val === state

        if (result)
          matches[action] = true
        else
          failures[action] = true
      })

      Object.keys(matches).forEach(action => {
        delete failures[action]
        addTransition(action, node)
      })

      Object.keys(failures).forEach(action => {
        var getUndo = transitionTypes[action].undoAction
        if (getUndo) {
          var undo = getUndo(node)
          if (undo)
            addTransition(undo, node)
        }
      })
    })

    return transitions
  }

  /// Restore state from object to UI avoiding all transition effects.
  /// @param state Accepts object like state attribute of type against value.
  restore(state) {
    this.state = state

    _.each(state, (val, type) => {
        if (val === null || val === 'null') {
          val = 'null'
          delete this.state[type]
        }

        var transitions = this._getTransitions(type, val)

        // remove animations for actions where possible...
        if (transitions.hide) {
          transitions.hide.hide()
          delete transitions.hide
        }

        if (transitions.show) {
          transitions.show.show()
          delete transitions.show
        }

        this._runTransitions(transitions)

        this.trigger(type + '-' + val, val)
    })
  }
}
